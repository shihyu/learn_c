<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html dir="ltr" lang="zh-tw">
  
<!-- Mirrored from openhome.cc/Gossip/Programmer/ParametricPolymorphism.html by HTTrack Website Copier/3.x [XR&CO'2008], Sun, 28 Jul 2013 09:04:20 GMT -->
<head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <title>多型的本質 （二）參數多型用於減輕型態負擔</title>
    <meta content="caterpillar" name="author">
    <meta content="Programmer" name="keywords">
    <link href="css/std.css" rel="stylesheet" type="text/css">
  </head>
  <body>
    <div class="header">
      <div class="hgroup">
        <h3><a href="../index.html">From Gossip@Openhome</a></h3>
        <h1><a href="index-2.html">程式人專欄: 多型的本質 （二）參數多型用於減輕型態負擔<br>
          </a></h1>
      </div>
    </div>
    <div class="article"> iThome 網站首載：<a href="http://www.ithome.com.tw/itadm/article.php?c=75186">多型的本質 （二）參數多型用於減輕型態負擔</a><br>
      <br>
      特定（Ad-hoc）多型允許函式根據不同引數型態，而有不同實作版本或行為，天平的另一端是參數（Parametric）多型，允許函式設計時不理會參數實際型態，函式的實作版本只有一個，呼叫時則可套用不同類型的引數，由於程式語言上的多型，是可使用一致介面來處理不同的資料型態，從這點來看，參數多型才是多型最純綷的型式。<br>
      <br>
      <dl>
        <dt>具靜態型別安全檢查功能的泛型函式</dt>
      </dl>
      <br>
      有些需求使用函式解決時並不需要在意傳入的資料型態，設計函式時可以空泛地定義參數型態，這類函式稱為泛型（Generic）函式。例如交換陣列兩元素的需求，若使用JDK 1.5以後的版本，可以使用泛型語法設計為：<br>
      <div class="courier" style="margin-left: 40px;"><span><strong>&lt;T&gt; T[] swap(T[] arrs, int i, int j) {</strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp; T orgi = arrs[i]; </strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp; </strong></span><span><strong>arrs[i] = arrs[j]; </strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp; </strong></span><span><strong>arrs[j] = orgi; </strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp; </strong></span><span><strong>return arrs; </strong></span><span><strong><br>
          </strong></span><span><strong>}</strong></span><span><strong><br>
          </strong></span></div>
      <br>
      傳入陣列的元素型態都是<span class="courier">T</span>型態，但T實際上是型態變數（Type variables），用以取代實際的型態宣告，泛型語法就是Java中實現參數多型的方式：<br>
      <br>
      參數多型讓函式定義時更具涵蓋性，並同時具有靜態型別編譯時期安全檢查功能。例如可以使用<span class="courier">String[] result = swap(original, 1, 2)</span>來呼叫<span
        class="courier">swap</span>函式，傳入物件是<span class="courier">String[]</span>，傳回物件就會是<span
        class="courier">String[]</span>，若使用其他型態宣告<span class="courier">result</span>，編譯器就會檢查出這個錯誤。<br>
      <br>
      JDK 1.4前沒有泛型語法，相同需求必須使用次型態多型來達成，也就是定義函式為<span class="courier">Object[] swap(Object[] arrs, int i, int j)</span>，如果實際上傳入物件是<span
        class="courier">String[]</span>，呼叫後傳回物件必須進行轉型，例如<span class="courier">String[] result = (String[]) swap(original, 1, 2)</span>，轉型語法只是要求編譯器停止該語句的型態檢查，真正的轉型是在執行時期進行，既然編譯時期使用轉型語法要求編譯器不要檢查型態，執行時期轉型失敗就得自行負責。<br>
      <br>
      參數多型實際上必須依賴編譯器的類型推斷（Type inference）功能，例如<span class="courier">String[] result = swap(original, 1, 2)</span>時，編譯器可由<span
        class="courier">original</span>推斷出T實際上會是<span class="courier">String</span>，從而得知傳回物件為<span
        class="courier">String[]</span>。有時為了規範型態變數的範圍，可對型態變數加上約束。例如取陣列中最大值的<span
        class="courier">max</span>函式，可以定義為：<br>
      <div class="courier" style="margin-left: 40px;"><span><strong>&lt;T extends Comparable&gt; T max(T[] arrs)</strong></span><span><strong> {</strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp; T max = arrs[0];</strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp; for(T elem : arrs) if(elem.compareTo(max) &gt; 0) { </strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong></span><span><strong>max = elem; </strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp; </strong></span><span><strong>}</strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp; return max;</strong></span><span><strong><br>
          </strong></span><span><strong>}</strong></span><strong><br>
        </strong></div>
      <br>
      這是由於Java中定義物件可比較性時，必須實現<span class="courier">Comparable</span>行為，你可以說<span
        class="courier">&lt;T extends Comparable&gt;</span>是要求編譯器進一步約束傳入物件必須具有<span
        class="courier">Comparable</span>行為，也可以說為了讓編譯器確認每個元素都有<span class="courier">compareTo()</span>方法可供操作，讓<span
        class="courier">max</span>函式現階段可以完成編譯。<br>
      <br>
      <dl>
        <dt>類別型態也能參數化加深了複雜性</dt>
      </dl>
      <br>
      在函數式語言中隨處可見參數多型的應用，因而都直接稱「多型」而不特別稱參數多型。以Haskell為例，配合編譯器強大的類型推斷功能，定義函式時幾乎可忽略型態變數的存在（因為基本上連型態都不用宣告）。例如同樣以取清單中最大值的<span
        class="courier">max'</span>函式為例，Haskell中可以如下定義：<br>
      <div class="courier" style="margin-left: 40px;"><span><strong>max' [] = error "empty list"</strong></span><span><strong><br>
          </strong></span><span><strong>max' [x] = x</strong></span><span><strong><br>
          </strong></span><span><strong>max' (x:xs) = max x (max' xs)</strong></span><strong><br>
        </strong></div>
      <br>
      在上例中看不到型態變數的存在，也看不到型態類（Typeclasses）約束，但實際上<span class="courier">max'</span>函式宣告是<span
        class="courier">(Ord a) =&gt; [a] -&gt; a</span>，<span class="courier">Ord</span>即類似Java中<span
        class="courier">Comparable</span>的角色，然而這個宣告定義可由編譯器自動推斷整個函式定義得知，強大的型態推斷結合參數多型，使得開發者減輕不少型態定義上的負擔。<br>
      <br>
      參數多型的原意，是減輕開發者使用靜態語言時必須時刻在意型態問題的負擔。對於將執行時期發生轉型錯誤的可能性，移轉至編譯時期就檢查出錯誤而言，Java的泛型確實達到這個目的，然而Java泛型語法本身可讀性不佳，單就前幾個Java泛型函式定義範例，就可看出端倪，Java本身又支援物件導向，如果將參數多型從函式擴展到類別，讓類別型態也可以參數化，就會使得情況更加複雜。<br>
      <br>
      以Java的群集（Collection）為例，由於收集的物件多半是同質的（Homogeneous），為了讓編譯器協助開發者檢查出型態錯誤，而引進了<span
        class="courier">Colllection&lt;E&gt;</span>的泛型語法，E是型態變數，如果開發者宣告變數時使用<span
        class="courier">Collection&lt;String&gt;</span>，那麼編譯器就不允許收集<span
        class="courier">String</span>以外的物件，從而避免了執行時期<span class="courier">ClassCastException</span>的問題。<br>
      <br>
      然而實際上，類別型態也可以參數化的結果，等於是對原有型態系統進了極大擴充。<span class="courier">Collection&lt;String&gt;</span>可看作一種型態、<span
        class="courier">Collection&lt;Customer&gt;</span>也是一種型態，既然將型態變數實例化後的結果都可視作一種型態，那麼就會衍生出<span
        class="courier">Collection&lt;Collection&lt;Customer&gt;&gt;</span>這類複雜的語法，即使Java群集框架的實現領導者Joshua Bloch喜歡泛型，認為在某些方面還是能實現簡潔度，但看到<span
        class="courier">Enum&lt;E extends Enum&lt;E&gt;&gt;</span>之類的語法，就覺得泛型的設計還不夠成熟到能放入Java中。<br>
      <br>
      <dl>
        <dt>繼承與參數多型又衍生出變異性的問題</dt>
      </dl>
      <br>
      類別型態也能參數化，因而加深了原有型態系統的複雜度，若再加上繼承的問題，得再考慮更複雜的變異性（Variance）問題。在型態系統中，如果型態階層與取代階層的方向一致，稱之為正變性（Covariance），反正則稱為逆變性（Contravariance），兩者皆非則為不變的（Invariant）。<span
        class="courier">以泛型來說，如果Banana繼承Fruit，而List&lt;Banana&gt;視為一種List&lt;Fruit&gt;，則稱List&lt;E&gt;具有共變性，如果List&lt;Fruit&gt;視為一種List&lt;Banana&gt;，則稱List&lt;E&gt;具有逆變性。</span><br>
      <br>
      Java的泛型不具共變性，所以<span class="courier">List&lt;Banana&gt;不是一種List&lt;Fruit&gt;，因而不能設計show(List&lt;Fruit&gt; fs)來顯示List&lt;Banana&gt;與List&lt;Apple&gt;（如果Banana與Apple都繼承自Fruit），但這個需求確實存在</span>，Java中可使用?型態通配字元（Wild card）與<span
        class="courier">extends來宣告變數，使其達到類似正變性，也就是設計show(List&lt;? extends Fruit&gt; fs)來接受List&lt;Banana&gt;與List&lt;Apple&gt;。</span><span><br>
      </span><br>
      Java的泛型不具逆變性，所以<span class="courier">List&lt;Fruit&gt;不是一種List&lt;Apple&gt;，這就有個困擾，如果要設計sort函式，希望可以傳入一個Comparator&lt;Fruit&gt;對List&lt;Apple&gt;或List&lt;Banana&gt;排序，顯然不能設計為sort(List&lt;T&gt; list, Comparator&lt;T&gt; c)，以傳入List&lt;Apple&gt;為例，這時相當於sort(List&lt;Apple&gt; list, Comparator&lt;Apple&gt; c)，這樣的話就不能接受Comparator&lt;Fruit&gt;作為第二個參數了。</span>Java可以使用<span
        class="courier">?型態通配字元與super來宣告變數，使其達到類似逆變性，也就是設計sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)，以傳入List&lt;Apple&gt;為例，這時相當於sort(List&lt;Apple&gt; list, Comparator&lt;? super Apple&gt; c)，原先設計的Comparator&lt;Fruit&gt;</span>也就可以傳入...然而...這一切實在是太複雜了...<br>
      <br>
      <dl>
        <dt>參數多型是為了簡化而不是複雜化</dt>
      </dl>
      <br>
      參數多型出發點是為了減輕開發者處理型態的負擔，允許函式設計時不理會參數實際型態，從而設計出介面更一致的函式，並進一步得到編譯時期的型態安全檢查，這份苦差事顯然落到了編譯器頭上，具有強大類型推斷功能的Haskell從參數多型得到了益處，函式設計時彷若動態語言，不用在乎參數型態，但又得到實質的編譯時期型態安全檢查。<br>
      <br>
      Java本身類型推斷功能有限，泛型語法本身亦不簡潔，考慮類別參數化會使得型態系統變得複雜，繼承而衍生出的變異性問題又使得觀念及語法更加魔幻，然而Java泛型不是沒有優點，一開始在Java中加入泛型也是為了減輕開發者一些手工任務，像是基本的泛型函式與收集同質物件的需求，使用泛型確實可以簡化程式，然而使用泛型是為了簡化而不是使程式複雜，若開始涉及<span
        class="courier">Enum&lt;E extends Enum&lt;E&gt;&gt;</span>之類的語法，或是面對變異性問題時，就應捨棄泛型，因為語法複雜度帶來的缺點已經超越編譯器給的優點，此時回歸特定多型或次型態多型也許才是正確的處理方式，例如先前排序需求可宣告為<span
        class="courier">sort(List list, Comparator c)</span>，在必要時明確進行轉型，反倒是簡潔明確的作法。<br>
      <br>
      <br>
      <br>
      <p></p>
      <p></p>
      <ul>
      </ul>
    </div>
    <div class="aside">
      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->
      </script>
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js">
      </script> <br>
      <br>
      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->
      </script>
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js">
      </script> <br>
      <br>
      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->
      </script>
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js">
      </script> <br>
      <br>
      <br>
    </div>
    <script src="../../../www.google-analytics.com/urchin.js" type="text/javascript">
</script> <script type="text/javascript">
_uacct = "UA-143766-1";
urchinTracker();
</script> </body>

<!-- Mirrored from openhome.cc/Gossip/Programmer/ParametricPolymorphism.html by HTTrack Website Copier/3.x [XR&CO'2008], Sun, 28 Jul 2013 09:04:20 GMT -->
</html>
