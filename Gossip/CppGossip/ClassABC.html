<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>

<!-- Mirrored from openhome.cc/Gossip/CppGossip/ClassABC.html by HTTrack Website Copier/3.x [XR&CO'2008], Sun, 28 Jul 2013 09:08:08 GMT -->
<head>



  
  
  <link rel="stylesheet" href="css/stdlayout.css" type="text/css">



  
  
  <link rel="stylesheet" href="css/print.css" type="text/css">



  
  
  <meta content="text/html; charset=Big5" http-equiv="content-type">


  
  
  <title>簡介類別（Class）</title>
</head>


<body>



<h3><a href="../index.html">From
Gossip@Openhome</a></h3>



<h1><a href="index.html">C++
Gossip: 簡介類別（Class）</a></h1>



<table style="text-align: left; width: 946px; height: 32px;" border="0" cellpadding="0" cellspacing="0">



  <tbody>



    <tr>



      <td style="width: 676px; vertical-align: top;"> <small>
class是C++中用來封裝資料的關鍵字，當您使用類別來定義一個物件（Object）時，您考慮這個物件可能擁有的「屬性」（Property）與
「方法」（Method），屬性是物件的靜態描述，而方法是可施加於物件上的動態操作，您使用類別定義出這個物件的規格書，之後就可依這個規格書製作出一
個個的物件實例，並在製作過程中設定個別物件的專屬特性資料。 <br>


      <br>



舉個例子來說，您可以定義一個「球」的模子，考慮球有各種不同的顏色（或名稱），以及球最基本的球半徑資訊，您想到這些資訊應該可以取得，並可以進一步取
得球的體積，當您在C++中要包裝這些資訊時，您可以如下進行定義： </small>
      <br>



      
      
      <ul>


        <li>Ball.h</li>


      
      
      </ul>



      
      
      <pre>#include &lt;string&gt;<br>using namespace std;<br><br>class Ball { <br>public: <br>    Ball(); <br>    Ball(double, const char*); <br>    Ball(double, string&amp;); <br> <br>    double radius();<br>    string&amp; name(); <br> <br>    void radius(double); <br>    void name(const char*); <br>    void name(string&amp;); <br> <br>    double volumn(); <br><br>private:<br>    double _radius; // 半徑 <br>    string _name; // 名稱 <br>};</pre>



      <br>


      <small>
您在表頭檔案中定義類別，表頭檔案的名稱建議與類別名稱同名，一個定義良好的類別，即使在不看程式碼實作的情況下，也可以從定義中看出這個類別的大致功
能；class是C++中用來定義類別的關鍵字，Ball是我們取得類別名稱，記得一個類別的定義是這麼作的： <br>


      </small>
      
      
      <div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">class
Ball { </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">



      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;
&nbsp; //
成員定義</span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">



      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">};</span><br>



      </small></div>



      <small><br>



最重要的是別忘了在最後加上分號，初學C++的新手很常犯這個錯誤；接下來定義類別的成員，注意到public這個關鍵字，它表示以下所定義的成員可以使
用物件名稱直接被呼叫，也稱之為「公用成員」或「公開成員」，private關鍵字下的則是「私用成員」或「私有成員」，不可以透過物件名稱直接呼叫。<br>


      <br>



在類別封裝時，有一個基本原則是：資訊的最小化公開。如果屬性可以不公開就不公開，如果要取得或設定物件的某些屬性，也是儘量透過方法成員來進行。 <br>


      <br>



資訊的最小化公開原則是基於安全性的考量，避免程式設計人員隨意操作屬性成員而造成程式的錯誤，您可以在日後的程式設計中慢慢來體會；在稍後的實作中，您
將可以看到，我將不會radius與name兩個私用成員直接進行存取，而是透過公開的方法來進行設定。 <br>


      <br>



接下來實作類別的內容： </small>


      <br>



      
      
      <ul>


        <li>Ball.cpp</li>


      
      
      </ul>



      
      
      <pre>#include &lt;string&gt;<br>#include "Ball.h"<br>using namespace std;<br><br>// 預設建構函式<br>Ball::Ball() {<br>    _radius = 0.0; <br>    _name = "noname ball"; <br>}<br><br>Ball::Ball(double radius, const char *name) { <br>    _radius = radius; <br>    _name = name;<br>}<br><br>Ball::Ball(double radius, string &amp;name) { <br>    _radius = radius; <br>    _name = name;<br>}<br><br>double Ball::radius() { <br>    return _radius; <br>} <br><br>double Ball::volumn() { <br>    return (4 / 3 * 3.14159 * _radius * _radius * _radius); <br>} <br><br>string&amp; Ball::name() { <br>    return _name; <br>} <br><br>void Ball::radius(double radius) { <br>    _radius = radius; <br>} <br><br>void Ball::name(string &amp;name) { <br>    _name = name; <br>}<br><br>void Ball::name(const char *name) { <br>    _name = name; <br>}</pre>



      <br>


      <small>
類別的實作檔案通常與類別名稱同名，如此例中的Ball.cpp，與類別名稱同名的方法稱之為「建構函式」（Constructor），也有人稱之為「建
構子」，它沒有傳回值，建構函式的作用在於物件生成時自動初始一些必要的資訊，它可以被過載，以滿足物件生成時不同的設定條件。 <br>


      <br>



「::」稱之為類別範圍解析（Class scope
resolution）運算子，在實作類別方法時，在::之前指明您要實作的是哪一個類別的方法，您在實作中過載了建構函式，在不指定引數的情況下，會將
radius設定為0，而name設定為"noname
ball"，另兩個建構函式則可以指定引數，無參數數建構函式是預設建構函式，如果您沒有定義預設建構函式，則編譯器會自動幫您產生一個無實作內容的預設
建構函式。<br>


      <br>



定義好類別之後，您就可使用這個類別來建立物件，例如： <br>


      </small>


      
      
      <div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">Ball
ball1; </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">



      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">Ball
ball2(5.0,
"black ball");</span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">



      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">string
name("yellow ball");</span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">



      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">Ball
ball3(10.0,
name);</span><br>



      </small></div>



      <small><br>



也可以這麼建立物件：<br>


      </small>
      
      
      <div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">Ball
ball1 = Ball(5.0,
"black ball");</span><br>



      </small></div>



      <small><br>



這有些類似宣告變數，使用類別建立的變數稱其為「物件」（Object）或「實例」（Instant），在上例中就是ball1、ball2與ball3
三個物件，ball1物件在建立時並不指定任何參數，所以根據之前實例建構函式的內容，b1的radius將設定為0.0，name設定為"noname
ball"；ball2則給定兩個參數，所以ball2的radius設定為5.0，而ball2的name設定為"black
ball"；ball3則是給定radius引數為10.0，第二個參數則給定string實例。 <br>


      <br>



您可以透過公開成員來操作物件或取得物件資訊，方法是使用物件名稱加上「.」運算子，例如： <br>


      </small>

      
      
      <div style="margin-left: 40px; font-family: Courier New,Courier,monospace;"><small><span style="font-weight: bold;">ball1.name("green
ball");</span><br>



      </small></div>



      
      
      <div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">cout
&lt;&lt;
ball1.name() &lt;&lt; endl;</span><br>



      <br>



      </small></div>


      <small>
以下是使用Ball類別的一個實際例子：</small><br>



      
      
      <ul>


        <li>main.cpp</li>


      
      
      </ul>



      
      
      <pre>#include &lt;iostream&gt; <br>#include "Ball.h"<br>using namespace std; <br><br>int main() {<br>    Ball ball1;<br>    cout &lt;&lt; ball1.name() &lt;&lt; "\t"<br>         &lt;&lt; ball1.volumn() <br>         &lt;&lt; endl;<br> <br>    ball1.name("green ball");<br>    ball1.radius(2.5);<br>    cout &lt;&lt; ball1.name() &lt;&lt; "\t"<br>         &lt;&lt; ball1.volumn() <br>         &lt;&lt; endl;<br><br>    Ball ball2(5.0, "black ball");<br>    cout &lt;&lt; ball2.name() &lt;&lt; "\t"<br>         &lt;&lt; ball2.volumn() <br>         &lt;&lt; endl; <br> <br>    string name("yellow ball");<br>    Ball ball3(10.0, name);<br> <br>    cout &lt;&lt; ball3.name() &lt;&lt; "\t"<br>         &lt;&lt; ball3.volumn() <br>         &lt;&lt; endl;<br> <br>    return 0; <br>}<br></pre>



      <br>



      <small><span class="postbody">
執行結果：</span></small><br>



      
      
      <table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">



        <tbody>



          <tr>



            <td style="background-color: rgb(0, 0, 0);"><small><span style="color: rgb(255, 255, 255);">noname
ball&nbsp;&nbsp;&nbsp;&nbsp;
0<br>



green ball&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;
&nbsp;49.0873<br>



black ball&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;
&nbsp; 392.699<br>



yellow ball&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 3141.59</span></small><span style="color: rgb(255, 255, 255);"><br>



            </span></td>



          </tr>



        
        
        </tbody>
      
      
      </table>



      <br>


      <small>
對於簡單的成員函式，您可以將之實作於類別定義中，在類別定義中即實作的函式會自動成為inline函式，例如：</small><br>



      
      
      <ul>


        <li>Ball.h</li>


      
      
      </ul>



      
      
      <pre>#include &lt;string&gt;<br>using namespace std;<br><br>class Ball { <br>public: <br>    Ball(); <br>    Ball(double, const char*); <br>    Ball(double, string&amp;); <br> <br>    // 實作於類別定義中的函式會自動inline<br>    double radius() {<br>        return _radius;<br>    }<br> <br>    string&amp; name() {<br>        return _name; <br>    }<br> <br>    void radius(double radius) {<br>        _radius = radius;<br>    } <br> <br>    void name(const char *name) {<br>        _name = name;<br>    }<br> <br>    void name(string&amp; name) {<br>        _name = name;<br>    }<br> <br>    double volumn() {<br>        return (4 / 3 * 3.14159 * _radius * _radius * _radius); <br>    }<br> <br>private:<br>    double _radius; // 半徑 <br>    string _name; // 名稱 <br>};</pre>



      <br>



      
      
      <ul>


        <li>Ball.cpp</li>


      
      
      </ul>



      
      
      <pre>#include &lt;string&gt;<br>#include "Ball.h"<br>using namespace std;<br><br>// 預設建構函式<br>Ball::Ball() {<br>    _radius = 0.0; <br>    _name = "noname ball"; <br>}<br><br>Ball::Ball(double radius, const char *name) { <br>    _radius = radius; <br>    _name = name;<br>}<br><br>Ball::Ball(double radius, string &amp;name) { <br>    _radius = radius; <br>    _name = name;<br>}</pre>



      <br>


      <small>
在定義類別時，如果您只是需要使用到某個類別來宣告指標或是參考，但不涉及類別的生成或操作等訊息，則您可以作該類別的前置宣告（Forward
declaration），而不用含入該類別的定義，例如：</small><br>



      
      
      <ul>


        <li>Test.h</li>


      
      
      </ul>



      
      
      <pre>class Ball;<br><br>class Test { <br>public:<br>    Test();<br>    Test(Ball*); <br> <br>    Ball* ball(); <br>    void ball(Ball*);<br><br>private:<br>    Ball *_ball; // 名稱 <br>};<br></pre>



      <br>


      <small>
在定義Test類別時，您尚未真正使用Ball來建構物件進行操作，您只是用它來宣告一些名稱，則您只要使用前置宣告就可以了，實際實作類別時再含入
Ball.h表頭檔即可，例如：</small><br>



      
      
      <ul>


        <li>Test.cpp</li>


      
      
      </ul>



      
      
      <pre>#include "Test.h"<br>#include "Ball.h"<br><br>Test::Test() { <br>    _ball = new Ball;<br>}<br><br>Test::Test(Ball *ball) {<br>    _ball = ball;<br>}<br><br>Ball* Test::ball() {<br>    return _ball;<br>}<br><br>void Test::ball(Ball *ball) {<br>    _ball = ball; <br>}<br></pre>



      <br>


      <small>
如果您的類別定義有單一參數的建構函式（或除了第一個參數之外，其它參數都有預設值的建構函式），則預設會有自動轉換的作用，例如：<br>


      </small>
      
      
      <div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">class
Ball { </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">



      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">public:
      </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">



      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp;
Ball(const char*); </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">



      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;
&nbsp;...</span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">



      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">};</span><br>



      </small></div>



      <small><br>



則您可以使用以下的方式來建構物件並初始化：<br>


      </small>
      
      
      <div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">Ball
ball&nbsp;= "Green
ball";</span><br>



      </small></div>



      <small><br>



預設的轉換行為是由編譯器施行的，但有時是有危險的，如果您不希望編譯器自作主張，則您可以使用explicit修飾，告訴編譯器不要自作主張：<br>


      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">class
Ball { </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">


      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">public:
      </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">


      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp;
explicit&nbsp;Ball(const char*); </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">


      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;
&nbsp;...</span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">


      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">};</span></small>




 </td>



      <td style="width: 250px; text-align: center; vertical-align: top;"><comment title=" adsense for content" xmlns="http://disruptive-innovations.com/zoo/nvu"></comment>&nbsp;
      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->
      </script>
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js">
      </script><br>

      <comment title=" adsense for content end" xmlns="http://disruptive-innovations.com/zoo/nvu"></comment><br>

      <comment title=" adsense for content" xmlns="http://disruptive-innovations.com/zoo/nvu"></comment>
      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->&#160;</script>&nbsp;
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js"></script><comment title=" adsense for content end" xmlns="http://disruptive-innovations.com/zoo/nvu"></comment><br>

      <br><script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->&#160;</script>&nbsp;
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js"></script><comment title=" adsense for content end" xmlns="http://disruptive-innovations.com/zoo/nvu"></comment><br>

      <br>
      <center>
       <br>

      </center>

 </td>



    </tr>



  
  
  </tbody>
</table>


      <br>



<script src="../../../www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-143766-1";
urchinTracker();
</script>
</body>

<!-- Mirrored from openhome.cc/Gossip/CppGossip/ClassABC.html by HTTrack Website Copier/3.x [XR&CO'2008], Sun, 28 Jul 2013 09:08:08 GMT -->
</html>
