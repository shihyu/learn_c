<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!-- Mirrored from openhome.cc/Gossip/CppGossip/LogicalBitwise.html by HTTrack Website Copier/3.x [XR&CO'2008], Sun, 28 Jul 2013 09:08:07 GMT -->
<head>








  
  
  
  
  
  <link rel="stylesheet" href="css/stdlayout.css" type="text/css">






  
  
  
  
  
  <link rel="stylesheet" href="css/print.css" type="text/css">






  
  
  
  
  
  <meta content="text/html; charset=Big5" http-equiv="content-type"><title>邏輯運算、位元運算</title></head><body>






<h3><a href="../index.html">From
Gossip@Openhome</a></h3>






<h1><a href="index.html">C++
Gossip:&nbsp;邏輯運算、位元運算</a></h1>






<table style="text-align: left; width: 946px; height: 32px;" border="0" cellpadding="0" cellspacing="0">






  <tbody>






    <tr>






      <td style="width: 676px; vertical-align: top;"><small>

在邏輯上有所謂的「且」、「或」與「反」運算，在C++中也提供這幾個基本邏輯運算所需的「邏輯運算子」（Logical
operator），分別為「且」（&amp;&amp;）、「或」（||）及「反相」（!）三個運算子。 <br>




      <br>






來看看下面這個程式會輸出什麼？ <br>




      </small>



      
      
      
      
      <div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">int
num = 75; </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">






      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">cout
&lt;&lt;&nbsp; (num &gt; 70 &amp;&amp; num
&lt; 80) &lt;&lt; endl; </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">






      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">cout
&lt;&lt; (num &gt; 80 || num &lt; 75) &lt;&lt;
endl; </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">






      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">cout
&lt;&lt; !(num &gt; 80 || num &lt; 75) &lt;&lt;
endl;</span><br>






      </small></div>






      <small><br>






三段程式分別會輸出1、0與1，也就是分別表示true、false與true三種狀況。 <br>




      <br>






&amp;&amp;運算中，如果左邊的式子已經被評斷為false，則可立即判斷整個式子為false，因而右邊的式子就不會再評斷；
|| 運算中如果左邊的式子已經被評斷為true，則可以判斷整個式子為true，因而右邊的式子就不會再評斷。<br>




      <br>






接下來看看「位元運算子」（Bitwise
operator），數位設計上有AND、OR、NOT、XOR與補數等運算，在C++中提供這些運算的就是位元運算子，它們的對應分別是AND
（&amp;）、OR（|）、NOT（!）、XOR（^）與補數（~）。 <br>




      <br>






如果您不會基本的位元運算，這邊可以提供一個程式來顯示各個運算的結果： </small>





      <br>






      <br>






      
      
      
      
      <pre>#include &lt;iostream&gt;<br>using namespace std;<br> <br>int main() { <br>    cout &lt;&lt; "AND運算：" &lt;&lt; endl; <br>    cout &lt;&lt; "0 AND 0\t\t" &lt;&lt; (0 &amp; 0) &lt;&lt; endl; <br>    cout &lt;&lt; "0 AND 1\t\t" &lt;&lt; (0 &amp; 1) &lt;&lt; endl; <br>    cout &lt;&lt; "1 AND 0\t\t" &lt;&lt; (1 &amp; 0) &lt;&lt; endl; <br>    cout &lt;&lt; "1 AND 1\t\t" &lt;&lt; (1 &amp; 1) &lt;&lt; endl; <br><br>    cout &lt;&lt; "OR運算：" &lt;&lt; endl; <br>    cout &lt;&lt; "0 OR 0\t\t" &lt;&lt; (0 | 0) &lt;&lt; endl; <br>    cout &lt;&lt; "0 OR 1\t\t" &lt;&lt; (0 | 1) &lt;&lt; endl; <br>    cout &lt;&lt; "1 OR 0\t\t" &lt;&lt; (1 | 0) &lt;&lt; endl; <br>    cout &lt;&lt; "1 OR 1\t\t" &lt;&lt; (1 | 1) &lt;&lt; endl; <br><br>    cout &lt;&lt; "XOR運算：" &lt;&lt; endl; <br>    cout &lt;&lt; "0 XOR 0\t\t" &lt;&lt; (0 ^ 0) &lt;&lt; endl; <br>    cout &lt;&lt; "0 XOR 1\t\t" &lt;&lt; (0 ^ 1) &lt;&lt; endl; <br>    cout &lt;&lt; "1 XOR 0\t\t" &lt;&lt; (1 ^ 0) &lt;&lt; endl; <br>    cout &lt;&lt; "1 XOR 1\t\t" &lt;&lt; (1 ^ 1) &lt;&lt; endl; <br><br>    cout &lt;&lt; "NOT運算：" &lt;&lt; endl; <br>    cout &lt;&lt; "NOT 0\t\t" &lt;&lt; (!0) &lt;&lt; endl; <br>    cout &lt;&lt; "NOT 1\t\t" &lt;&lt; (!1) &lt;&lt; endl; <br> <br>    return 0;<br>}</pre>






      <br>




      <small>

執行結果如下： </small><br>






      
      
      
      
      <table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">






  <tbody>






    <tr>






      <td style="background-color: rgb(0, 0, 0);"><small><span style="color: rgb(255, 255, 255);">AND運算： <br>






0 AND
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0 <br>






0 AND
1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0 <br>






1 AND
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0 <br>






1 AND
1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1 <br>






OR運算： <br>






0 OR
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0 <br>






0 OR
1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1 <br>






1 OR
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1 <br>






1 OR
1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1 <br>






XOR運算： <br>






0 XOR
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0 <br>






0 XOR
1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1 <br>






1 XOR
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1 <br>






1 XOR
1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0 <br>






NOT運算： <br>






NOT
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1 <br>






NOT
1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0<br>






      </span></small></td>






    </tr>






  
        
        
        
        
        </tbody>
      
      
      
      
      </table>






      <br>




      <small>

C++中的位元運算是逐位元運算的，例如10010001與01000001作AND運算，是一個一個位元對應運算，答案就是00000001；而補數運
算是將所有的位元0變1，1變0，例如00000001經補數運算就會變為11111110，例如下面這個程式所示： <br>




      </small>

      
      
      
      
      <div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">char
num = 255; </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">






      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">cout
&lt;&lt;&nbsp;static_cast&lt;int&gt;(~num);</span><br>






      </small></div>






      <small><br>






這段程式會在主控台顯示0，char使用一個位元組，若用於儲存正整數最大可儲存255的值，255的二進位表示法為11111111，經補數運算就是
00000000，也就是0。 <br>




      <br>






要注意的是，邏輯運算子與位元運算子也是很常被混淆的，像是&amp;&amp;為邏輯運算，而&amp;為位元運算，||為邏
輯運算，而|為位元運算，
初學時可得多注意。 <br>


      </small><small><br>






位元運算對初學者來說的確較不常用，但如果用的洽當的話，可以增進不少程式效率，例如下面這個程式可以判斷使用者的輸入是否為奇數：</small>



      <br>






      <br>






      
      
      
      
      <pre>#include &lt;iostream&gt;<br>using namespace std;<br><br>int main() { <br>    int input = 0; <br><br>    cout &lt;&lt; "輸入正整數："; <br>    cin &gt;&gt; input; <br>    cout &lt;&lt; "輸入為奇數？" <br>         &lt;&lt; (input&amp;1 ? 'Y' : 'N') <br>         &lt;&lt; endl; <br> <br>    return 0;<br>}</pre>






      <br>




      <small>

執行結果如下： </small><br>






      
      
      
      
      <table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">






  <tbody>






    <tr>






      <td style="background-color: rgb(0, 0, 0);"><small><span style="color: rgb(255, 255, 255);">輸入正整數：5<br>






輸入為奇數？Y<br>






      </span></small></td>






    </tr>






  
        
        
        
        
        </tbody>
      
      
      
      
      </table>






      <br>




      <small>

這個程式得以運算的原理是，奇數的數值若以二進位來表示，其最右邊的位元必為1，而偶數最右邊的位元必為0，所以您使用1來與輸入的值作AND運算，由於
1除了最右邊的位元為1之外，其它位元都會是0，與輸入數值AND運算的結果，只會留下最右邊位元為0或為的結果，其它部份都被0
AND運算遮掉了，這就是所謂「位元遮罩」，例如：</small><br>






      
      
      
      
      <table style="text-align: left; width: 25%;" border="0" cellpadding="2" cellspacing="2">






  <tbody>






    <tr>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>00000100</small></td>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>4</small></td>






    </tr>






    <tr>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>00000001</small></td>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>1</small></td>






    </tr>






    <tr>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>00000000</small></td>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>判
斷為偶數</small></td>






    </tr>






  
        
        
        
        
        </tbody>
      
      
      
      
      </table>






      <br>






      <br>






      
      
      
      
      <table style="text-align: left; width: 25%;" border="0" cellpadding="2" cellspacing="2">






  <tbody>






    <tr>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>00000011</small></td>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>3</small></td>






    </tr>






    <tr>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>00000001</small></td>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>1</small></td>






    </tr>






    <tr>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>00000001</small></td>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>判
斷為奇數</small></td>






    </tr>






  
        
        
        
        
        </tbody>
      
      
      
      
      </table>






      <br>






      <br>




      <small>

XOR的運算較不常見，這邊舉個簡單的XOR字元加密例子，先看看程式：</small><br>






      <br>






      
      
      
      
      <pre>#include &lt;iostream&gt;<br>using namespace std;<br> <br>int main() { <br>    char ch = 'A'; <br><br>    cout &lt;&lt; "before encoding：" &lt;&lt; ch <br>         &lt;&lt; endl; <br><br>    ch = ch^0x7; <br>    cout &lt;&lt; "after encoding：" &lt;&lt; ch <br>         &lt;&lt; endl; <br><br>    ch = ch^0x7; <br>    cout &lt;&lt; "decoding：" &lt;&lt; ch <br>         &lt;&lt; endl; <br> <br>    return 0;<br>}</pre>






      <br>




      <small>

執行結果如下： </small><br>






      
      
      
      
      <table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">






  <tbody>






    <tr>






      <td style="background-color: rgb(0, 0, 0);"><small><span style="color: rgb(255, 255, 255);">before encoding：A<br>






after encoding：F<br>






decoding：A<br>






      </span></small></td>






    </tr>






  
        
        
        
        
        </tbody>
      
      
      
      
      </table>






      <br>




      <small>

0x7是C++中整數的16進位寫法，其實就是10進位的7，將位元與1作XOR的作用其實就是位元反轉，0x7的最右邊三個位元為1，所以其實就是反轉
ch的最後兩個字元，如下所示：</small><br>






      
      
      
      
      <table style="text-align: left; width: 273px;" border="0" cellpadding="2" cellspacing="2">






  <tbody>






    <tr>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>01000001</small></td>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace; width: 191px;"><small>65
（對應
ASCII的'A'）</small></td>






    </tr>






    <tr>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>00000111</small></td>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace; width: 191px;"><small>0x7</small></td>






    </tr>






    <tr>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>01000110</small></td>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace; width: 191px;"><small>70
（對應
ASCII中的'F'）</small></td>






    </tr>






  
        
        
        
        
        </tbody>
      
      
      
      
      </table>






      <br>




      <small>

同樣的，這個簡單的XOR字元加密，要解密也只要再進行相同的位元反轉就可以了。 <br>




      <br>






要注意的是，雖然在說明時都只取8個位元來說明，但實際的位元在運算時，需依資料型態所佔的記憶體長度而定，例如在使用int型態的0作運算時，要考慮的
是32個位元，而不是只有8個位元，因為int佔有4個位元組。 <br>




      <br>






在位元運算上，C++還有左移（&lt;&lt;）與右移（&gt;&gt;）兩個運算子，注意在這邊與cout與
cin所使用的&lt;&lt;與
&gt;&gt;作用是不一樣的；左移運算子會將所有的位元往左移指定的位數，左邊被擠出去的位元會被丟棄，而右邊會補上0；右移運算則
是相反，會將所有
的位元往右移指定的位數，右邊被擠出去的位元會被丟棄，至於左邊位元補0或補1則不一定，視系統而定。 <br>




      <br>






您可以使用左移運算來作簡單的2次方運算示範，如下所示： </small>





      <br>






      <br>






      
      
      
      
      <pre>#include &lt;iostream&gt;<br>using namespace std;<br> <br>int main() { <br>    int num = 1; <br><br>    cout &lt;&lt; "2的0次：" &lt;&lt; num<br>         &lt;&lt; endl; <br><br>    num = num &lt;&lt; 1; <br>    cout &lt;&lt; "2的1次：" &lt;&lt; num<br>         &lt;&lt; endl; <br><br>    num = num &lt;&lt; 1; <br>    cout &lt;&lt; "2的2次：" &lt;&lt; num<br>         &lt;&lt; endl; <br><br>    num = num &lt;&lt; 1; <br>    cout &lt;&lt; "2的3次：" &lt;&lt; num <br>         &lt;&lt; endl; <br> <br>    return 0;<br>}</pre>






      <br>




      <small>

執行結果如下： </small><br>






      
      
      
      
      <table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">






  <tbody>






    <tr>






      <td style="background-color: rgb(0, 0, 0);"><small><span style="color: rgb(255, 255, 255);">2的0次：1<br>






2的1次：2<br>






2的2次：4<br>






2的3次：8<br>






      </span></small></td>






    </tr>






  
        
        
        
        
        </tbody>
      
      
      
      
      </table>






      <br>




      <small>

實際來左移看看就知道為何可以如此運算了： </small><br>






      
      
      
      
      <table style="text-align: left; width: 25%;" border="0" cellpadding="2" cellspacing="2">






  <tbody>






    <tr>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>00000001</small></td>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>1</small></td>






    </tr>






    <tr>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>00000010</small></td>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>2</small></td>






    </tr>






    <tr>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>00000100</small></td>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>4</small></td>






    </tr>






    <tr>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>00001000</small></td>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>8</small></td>






    </tr>






  
        
        
        
        
        </tbody>
      
      
      
      
      </table>





      </td>






      <td style="width: 250px; text-align: center; vertical-align: top;"><comment title=" adsense for content" xmlns="http://disruptive-innovations.com/zoo/nvu"></comment>&nbsp;
      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->
      </script>
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js">
      </script><br>

      <comment title=" adsense for content end" xmlns="http://disruptive-innovations.com/zoo/nvu"></comment><br>

      <comment title=" adsense for content" xmlns="http://disruptive-innovations.com/zoo/nvu"></comment>
      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->
      </script>
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js">
      </script><br>

      <br><script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->&#160;</script>&nbsp;
      <script type="text/javascript" src="../../../pagead2.googlesyndication.com/pagead/show_ads.js"></script><comment title=" adsense for content end" xmlns="http://disruptive-innovations.com/zoo/nvu"></comment><br>

      <br>
      <center>
       <br>

      </center>

 </td>






    </tr>






  
  
  
  
  
  </tbody>
</table>






<br>




<br>






<script src="../../../www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-143766-1";
urchinTracker();
</script>
</body>
<!-- Mirrored from openhome.cc/Gossip/CppGossip/LogicalBitwise.html by HTTrack Website Copier/3.x [XR&CO'2008], Sun, 28 Jul 2013 09:08:07 GMT -->
</html>